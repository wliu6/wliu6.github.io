<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>w66&#39;s blog</title>
  
  <subtitle>A man, will eventually become pirate king.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wliu6.github.io/"/>
  <updated>2022-07-15T02:34:54.389Z</updated>
  <id>http://wliu6.github.io/</id>
  
  <author>
    <name>王六六</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>behavior_daily_01</title>
    <link href="http://wliu6.github.io/2022/07/15/behavior-daily-01/"/>
    <id>http://wliu6.github.io/2022/07/15/behavior-daily-01/</id>
    <published>2022-07-15T02:34:54.000Z</published>
    <updated>2022-07-15T02:34:54.389Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift begin</title>
    <link href="http://wliu6.github.io/2019/10/03/swift-learn-01/"/>
    <id>http://wliu6.github.io/2019/10/03/swift-learn-01/</id>
    <published>2019-10-03T06:14:39.000Z</published>
    <updated>2021-06-04T04:24:59.202Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建设中<br><a id="more"></a></p></blockquote><hr><p><br></p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>调试</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;建设中&lt;br&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>网易云信 —— 版本管理方案</title>
    <link href="http://wliu6.github.io/2018/07/23/yx-im-scheme/"/>
    <id>http://wliu6.github.io/2018/07/23/yx-im-scheme/</id>
    <published>2018-07-23T11:58:36.000Z</published>
    <updated>2021-06-04T04:24:01.237Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近接到公司高层级需求，要将原有项目的IM服务渠道迁移成云信。由于产品规划设计需求深度定制了业务层面的功能与即时通讯功能的交互，从技术层面对这次迁移工作做了一个深度定制化方案，以便后期业务开发、维护以及同步云信更新功能的成本最小。</p><font color="#339933" size="2"><strong><em>——本文记录了集成网易云信的深度定制化方案。——</em></strong></font></blockquote><a id="more"></a><hr><p><br></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="读者视角"><a href="#读者视角" class="headerlink" title="读者视角"></a>读者视角</h2><p>本文以iOS PG为第一视角编辑，默认读者了解<code>CocoaPods</code>的使用、私有库以及私有库如何进行版本控制。</p><h2 id="业务复杂度"><a href="#业务复杂度" class="headerlink" title="业务复杂度"></a>业务复杂度</h2><p>关于业务复杂度的描述，由于涉及到公司业务，在此不会表述公司具体业务，通过其他表述来描述项目复杂度，复杂度主要体现在：</p><pre><code>* 群组 —— 分为多种类型，* 群组成员 —— 具有多种角色，不同角色具备不同的操作权限* 自定义消息 —— 多种，并且展示不同，并具备单独的未读状态* 用户 —— 更多的用户信息* 公告 —— 避免使用接口的延迟性，达到时效* ...</code></pre><p>对于产品大大们能规划、设计出这么多神奇的功能，有种的佩服。但是作为一名搬砖工一定要使用一个易于维护方案，不然以后每天的工作就是挖坑、埋土了…</p><p><br></p><h1 id="云信渠道技术调研"><a href="#云信渠道技术调研" class="headerlink" title="云信渠道技术调研"></a>云信渠道技术调研</h1><h2 id="业务调研"><a href="#业务调研" class="headerlink" title="业务调研"></a>业务调研</h2><p>在迁移之前做了下技术层面的调研，确保能满足所有业务需求。下图取自云信文档的云信架构图，图中介绍了云信的通信机制。<br><!-- ![img0](/resourse/iOS/YX_IM/0.png) --><br><img src="/resourse/iOS/YX_IM/0.png" width="600"><br>经过调研，发现云信支持用户信息自定义、群信息自定义、群成员信息自定义以及发送自定义消息，这完全能满足所有需求。同时云信提供了一套<code>IM-UI</code>库，可以直接拿来用（建议使用）。</p><h2 id="UI调研"><a href="#UI调研" class="headerlink" title="UI调研"></a>UI调研</h2><p>UI迁移方案有如下两种，</p><pre><code>方案一：直接在云信提供的`IM-UI`基础上增加业务修改；方案二：在原项目的`IM-UI`基础上替换socket的代理；</code></pre><p>相比之下方案一成本更低，且出错率更低，而且方案二有在测试阶段不易易识别隐藏bug的风险。故决定采用方案一进行迁移。</p><p><br></p><h1 id="云信渠道分析"><a href="#云信渠道分析" class="headerlink" title="云信渠道分析"></a>云信渠道分析</h1><p>云信IM服务渠道，对于自有项目来说算是外部资源。应该考虑其单独版本控制问题，例如：新版本有问题，可以在自有项目中依赖相对老的版本。<br><a href="http://dev.yunxin.163.com/docs/product/IM%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF/SDK%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/iOS%E5%BC%80%E5%8F%91%E9%9B%86%E6%88%90/%E9%9B%86%E6%88%90%E6%96%B9%E5%BC%8F?#%E8%87%AA%E5%8A%A8%E9%9B%86%E6%88%90" target="_blank" rel="noopener">云信SDK</a>、<a href="https://github.com/netease-im/NIM_iOS_UIKit" target="_blank" rel="noopener">云信UI</a>都可基于<code>CocoaPods</code>进行版本管理。但是基于业务、UED团队的需求，<a href="https://github.com/netease-im/NIM_iOS_UIKit" target="_blank" rel="noopener">云信UI</a>这个库一定是要修改，所以版本控制不能直接依赖<a href="https://github.com/netease-im/NIM_iOS_UIKit" target="_blank" rel="noopener">云信的UI仓库</a>，要通过镜像的方式去管理UI库的版本。</p><p><br></p><h1 id="UI仓库开发及版本控制规划"><a href="#UI仓库开发及版本控制规划" class="headerlink" title="UI仓库开发及版本控制规划"></a>UI仓库开发及版本控制规划</h1><h2 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h2><p>什么是镜像？小时候用<code>windows</code>转系统的镜像类比一下，懂了吧。简单理解就是基于模板copy的一个压缩备份。</p><h2 id="如何通过镜像的方式去管理UI库的版本"><a href="#如何通过镜像的方式去管理UI库的版本" class="headerlink" title="如何通过镜像的方式去管理UI库的版本"></a>如何通过镜像的方式去管理UI库的版本</h2><p>通过镜像的方式去管理UI库的版本，首先应建立一个本地两个远端仓库的关系。第一步，通过<code>git clone</code>工具将<a href="https://github.com/netease-im/NIM_iOS_UIKit" target="_blank" rel="noopener">云信UI仓库</a>克隆到本地；第二步，通过<code>git add remote</code>工具添加自己的git远端仓库。</p><p>接下来需要以自己的私有<code>git</code>仓库建立<a href="http://blog.pirate6.com/2016/07/20/cocoapods-private-repo-md/" target="_blank" rel="noopener"><code>CocoaPods</code>私有库</a>，打包上传的时候依赖该私有库，便可达到控制版本目的，比如实现IM模块单独回滚到上一个minor版本。</p><p>实际的代码数据流向如下图。只从<a href="https://github.com/netease-im/NIM_iOS_UIKit" target="_blank" rel="noopener">云信的UI仓库</a>拉取，获取云信的最新功能的UI支持。在本地进行开发，并上传至私有<code>git</code>仓库。验收通过合并到<code>master</code>分支，并打<code>tag</code>以用于<code>CocoaPods</code>进行控制版本。<br><!-- ![img2](/resourse/iOS/YX_IM/2.png) --><br><img src="/resourse/iOS/YX_IM/2.png" width="600"></p><!-- <br/># 业务交互规划![img1](/resourse/iOS/YX_IM/1.png)<img src="/resourse/iOS/YX_IM/1.png" width="600"> --><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过镜像的方式去管理UI库的版本，缺点是体力工作量稍微增多了一些；优点是降低耦合度，提高了风险应对能力。比如产品需求新增IM功能，在开发一段时间后，由于市场及业务原因不需要这个功能了，不需要手动去删除代码，直接版本回滚即可。而且这样做可以利用<code>git workflow</code>的所有优秀特性哟。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近接到公司高层级需求，要将原有项目的IM服务渠道迁移成云信。由于产品规划设计需求深度定制了业务层面的功能与即时通讯功能的交互，从技术层面对这次迁移工作做了一个深度定制化方案，以便后期业务开发、维护以及同步云信更新功能的成本最小。&lt;/p&gt;
&lt;font color=&quot;#339933&quot; size=&quot;2&quot;&gt;&lt;strong&gt;&lt;em&gt;——本文记录了集成网易云信的深度定制化方案。——&lt;/em&gt;&lt;/strong&gt;&lt;/font&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>运营策略 —— 对赌营销</title>
    <link href="http://wliu6.github.io/2018/07/15/marketing-strategy/"/>
    <id>http://wliu6.github.io/2018/07/15/marketing-strategy/</id>
    <published>2018-07-15T09:31:53.000Z</published>
    <updated>2021-04-21T08:59:21.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对于事件<code>“2018世界杯，法国夺冠华帝退全款”</code>进行分析与研究。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="事件介绍"><a href="#事件介绍" class="headerlink" title="事件介绍"></a>事件介绍</h1><p>2018年5月30日华帝宣告“法国队夺冠，华帝退全款”的口号，凡购买华帝“夺冠套餐”的消费者，全额退款。华帝董事长正式签字登报。<br><!-- 【图1——华帝董事长签字】 --><br><img src="/resourse/Marketing/hd_ gambling_marketing/hd-1.jpeg" alt="img1"></p><p>6月1日0时-6月30日22时期间，华帝销售了约8000万的“夺冠套餐”。<br><!-- 【图2——夺冠套餐内容】 --><br><img src="/resourse/Marketing/hd_ gambling_marketing/hd-2.png" alt="img2"></p><p><br></p><h1 id="事件分析"><a href="#事件分析" class="headerlink" title="事件分析"></a>事件分析</h1><p>虽说华帝的年营销额是60亿级别的，8000万的销售看似额看似九牛一毛。但是所谓“夺冠套餐”是有商品范围的，笔者暂时没有获取到华帝“夺冠套餐”的往年营销额，故不敢妄下结论说“夺冠套餐”系列产品已经达到了往年营销总额。</p><p>此外就“夺冠套餐”是有商品范围经限定了产品型号来看，“夺冠套餐”中的商品去库存的可能性很大。就好比 <strong>GIANT</strong> 在网上能够买到的永远是滞销的车型，爆款、高性能的只在专卖店销售；商场打折产品大多是尾货。</p><p>另外，本届世界杯广告投放的成本也很高，如国内知名企业海信、vivo都是过亿的赞助，但是华帝仅仅用了8000万。近一个月，“华帝退全款”连上各大新闻版面头条，已经成为国民级的话题，华帝的宣传效果明显要好于其他海信和vivo。使得华帝品牌的价值也大有提高。</p><p>今天最新消息，网购渠道华帝退的是购物卡。这么总额这么巨大的购物卡，猫厂和狗厂得购卡优惠幅度也是有的吧。<br><!-- 【图3——退购物卡图】 --><br><img src="/resourse/Marketing/hd_ gambling_marketing/hd-3.jpeg" alt="img3"></p><p>而且此前华帝股份证券事务代表王钊表示：“如果法国队真的夺冠，赔付的费用确实挺大，不过这都在年度营销预算内，不会对公司业绩产生重大影响。”</p><p>故，本事件的既得利益者是期间购买“夺冠套餐”的消费者和华帝集团，华帝这波对波营销，看似亏了8000万，实际并上不亏。如果此次法国🇫🇷凑巧没夺冠，那么华帝就是最大的赢家了…</p><p><br></p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>关于对赌式营销并没有官方的定义，因为运营学科的知识大多数都是隐性知识，需要通过实际案例场景来传导知识，而不是像理工科的知识点可以直接通过显性定义，进而传导给对知识有需求的团体。作为一名土鳖理工男（Ps: 是个‘轴’货），还是想定义一下“对赌式营销”，于是打算借鉴一下金融学的对赌协议。</p><p><strong><em>对赌协议</em></strong> —— 收购方（包括投资方）与出让方（包括融资方）在达成并购（或者融资）协议时，对于未来不确定的情况进行一种约定。如果约定的条件出现，融资方可以行使一种权利；如果约定的条件不出现，投资方则行使一种权利。</p><p>根据<strong><em>对赌协议</em></strong>的定义，定义了一下对赌式营销：<br><strong><em>对赌式营销</em></strong> —— 买方（消费者）与卖方（商家）在达成购买协议时，对于未来不确定的情况进行一种约定。如果约定的条件出现，买方可以行使一种权利（一般是免费购买、退款等）；如果约定的条件不出现，卖方则行使一种权利（买方需要正常付费购买）。</p><!-- <br/># 类比拼多多营销方案0.1元拼单购iPhone X， --><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对赌式营销，直接激活你内在以小博大的心理。激发人的贪念，故无往不利。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于事件&lt;code&gt;“2018世界杯，法国夺冠华帝退全款”&lt;/code&gt;进行分析与研究。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Marketing" scheme="http://wliu6.github.io/categories/Marketing/"/>
    
    
      <category term="Marketing" scheme="http://wliu6.github.io/tags/Marketing/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods Error —— [!] RPC failed;</title>
    <link href="http://wliu6.github.io/2017/11/21/cocoapods-issue1/"/>
    <id>http://wliu6.github.io/2017/11/21/cocoapods-issue1/</id>
    <published>2017-11-21T08:15:43.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 pod install 时报错<code>RPC failed; curl 18 transfer closed with outstanding read data remaining</code>，于此记录下问题。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="使用-CocoaPods-报错场景"><a href="#使用-CocoaPods-报错场景" class="headerlink" title="使用 CocoaPods 报错场景"></a>使用 CocoaPods 报错场景</h1><p>使用 CocoaPods 安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --verbose</span><br></pre></td></tr></table></figure></p><p>报错信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: RPC failed; curl 18 transfer closed with outstanding read data remaining </span><br><span class="line">fatal: The remote end hung up unexpectedly </span><br><span class="line">fatal: early EOF </span><br><span class="line">fatal: index-pack failed</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>分析一下报错信息，RPC因该是Remote Position Control的缩写，curl是常用的cmd下载工具，猜测应该是install过程的下载repo子过程出错了。CocoaPods的repo下载基于git，暂且猜测是git clone过程出问题了。</p><p>由于install是用了verbose option，从输出中可以拿到正在下载的repo下载的本地路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; Installing xxxSDK (3.4.2)</span><br><span class="line"> &gt; Git download</span><br><span class="line"> &gt; Git download</span><br><span class="line">     $ /usr/bin/git clone https://github.com/xxx/xxx.git /var/folders/f7/hx8jzq4d6yd60n4lvsjkqwm80000gn/T/d20180716-82840-xyqioz</span><br><span class="line">     --template= --single-branch --depth 1 --branch v3.4.2</span><br><span class="line">     Cloning into &apos;/var/folders/f7/hx8jzq4d6yd60n4lvsjkqwm80000gn/T/d20180716-82840-xyqioz&apos;...</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd /var/folders/f7/hx8jzq4d6yd60n4lvsjkqwm80000gn/T/d20180716-82840-xyqioz</span><br><span class="line">$ while : ;do du -sh; sleep 1; done;</span><br></pre></td></tr></table></figure><p>发现最终xxxSDK下载到96M就卡主不动了，nice，问题原因确定了，的确是在git clone过程出的问题，那么error phrase —— <code>RPC failed; curl 18 transfer closed with outstanding read data remaining</code> 应该是git clone过程的输出，定位到问题一切都好办，直接去搜一下git issue，果真找到解决办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global http.postBuffer 524288000</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>出现这个问题的根本原因，是因为笔者在最近升级了MacOS系统，导致随着系统连带着的git也升级了，全局配置在version 25.x之后默认不超过100M，哎。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 pod install 时报错&lt;code&gt;RPC failed; curl 18 transfer closed with outstanding read data remaining&lt;/code&gt;，于此记录下问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Git —— 数据恢复</title>
    <link href="http://wliu6.github.io/2017/07/23/git-issue0/"/>
    <id>http://wliu6.github.io/2017/07/23/git-issue0/</id>
    <published>2017-07-23T06:30:46.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用git硬回滚操作错误，导致马上要提交测试的代码丢失。研究了一下git数据恢复，并总结记录。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>早上回滚代码时，使用了错误的SHA-1值，导致丢失了一个明天要提测重要功能代码片段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 96edccd4ed9ced23296e8ccfdc78f89078177107</span><br></pre></td></tr></table></figure></p><p>解决问题的方法有两种，一种是直接重新编写该功能的代码，另一种是研究git的数据恢复。<br>(Ps：作为一名有上进心的程序猴，我还是抱着能get新知识点的心态去学习了一下git的数据恢复。)</p><p><br></p><h1 id="如何恢复commit数据"><a href="#如何恢复commit数据" class="headerlink" title="如何恢复commit数据"></a>如何恢复commit数据</h1><p>git数据恢复其实很简单，总共分两步。第一步，查找丢失的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></p><p>找到丢失的信息了，<code>feature-1127</code>这个是被删除的有用代码。</p><pre><code>3c0437194 HEAD@{1}: reset: moving to 3c043719499bfde00340fb9358c115f815bfe2a76cd4ee3dc HEAD@{2}: commit: refuse code96edccd4e HEAD@{3}: checkout: moving from Debug to merge_tmp96edccd4e HEAD@{4}: pull: Fast-forward6bd181333 HEAD@{5}: checkout: moving from network to Debugee3dc6cd4 HEAD@{6}: commit: feature-11273c0437194 HEAD@{6}: commit: feature-1126...</code></pre><p>第二步，根据正确的SHA-1值回滚到应该回滚的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard ee3dc6cd4</span><br></pre></td></tr></table></figure></p><p>验证是否成功找回丢失的提交index，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log -1</span><br></pre></td></tr></table></figure></p><p>最新的提交是<code>feature-1127</code>，证明成功找回丢失的提交。</p><pre><code>commit c1c3f278d959cf108b05ba8268321d01d73da8cf (HEAD -&gt; Develop)Author: 6 &lt;wangduorui@kaistart.com&gt;Date:   Fri Jul 20 18:43:37 2016 +0800    feature-1127</code></pre><p><br></p><h1 id="如何恢复branch数据"><a href="#如何恢复branch数据" class="headerlink" title="如何恢复branch数据"></a>如何恢复branch数据</h1><p>和恢复commit数据一样，只需要两部就可以恢复本地误删的<code>branch</code>。第一步，查找丢失的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure></p><p>很容易看出<code>HEAD@{2}</code>是被删除的分支的HEAD指向。</p><pre><code>c1c3f278d (HEAD -&gt; Develop, ksb/Develop) HEAD@{0}: checkout: moving from test_br to Develop0f9ef0947 HEAD@{1}: commit: testc1c3f278d (HEAD -&gt; Develop, ksb/Develop) HEAD@{2}: checkout: moving from Develop to test_br87bdd6dbf HEAD@{3}: commit: fixed unread30b0d8220 HEAD@{57}: commit: web hook...</code></pre><p>第二步，基于<code>HEAD@{2}</code>创建被删除的分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch lost-branch 0f9ef0947</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="pick知识点"><a href="#pick知识点" class="headerlink" title="pick知识点"></a>pick知识点</h1><p><strong>reflog</strong>是Reference Logs的缩写，意为引用日志丨调用日志，用于记录本地仓库的分支、更新操作（即：每一次HEAD改变）。<br><!-- 前文的数据恢复只是对于丢失的`commit`的恢复，按照`reflog`记录的信息，还可以恢复本地误删的分支。 --></p><p><br></p><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="关于reset"><a href="#关于reset" class="headerlink" title="关于reset"></a>关于reset</h2><p>执行<code>reset</code>操作并不会改变SHA-1值，所以在使用<code>reflog</code>工具查看日志时，会发现两个相同的SHA-1值的HEAD，可以帮助我们找到误删的<code>commit</code>。</p><h2 id="关于branch"><a href="#关于branch" class="headerlink" title="关于branch"></a>关于branch</h2><p>由于<code>git</code>不允许删除当前指向的分支，所以在删除分支之前的操作一定是切换分支<code>checkout:</code>。而且<code>reflog</code>工具在日志中会直接记录<code>moving from A_branch to B_branch</code>，所以直接按被删除的分支名进行查找即可。</p><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于硬回退可能导致误删有效<code>commit</code>，并且需要通过<code>reflog</code>工具才能找回；有分析成本，相对麻烦；建议在撤销无用的<code>commit</code>时，使用revert。<br>对于删除分支尽量先使用<code>git branch -d &lt;branch-name&gt;</code>，不要直接使用<code>git branch -D &lt;branch-name&gt;</code>。因为<code>git branch -D &lt;branch-name&gt;</code>是直接强制删除分支，而<code>git branch -d &lt;branch-name&gt;</code>会check一下当前处于分支是否有落后于删除目标分支的提交，如果有会不执行删除，并输入警告，这就让脑子有个思考过程，删除的分支改的东西是否真的没用。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用git硬回滚操作错误，导致马上要提交测试的代码丢失。研究了一下git数据恢复，并总结记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="git" scheme="http://wliu6.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods Error —— [!] Oh no, an error occurred.</title>
    <link href="http://wliu6.github.io/2017/06/26/cocoapods-issue0/"/>
    <id>http://wliu6.github.io/2017/06/26/cocoapods-issue0/</id>
    <published>2017-06-26T03:23:06.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用 pod search ‘xxx’ 时报错 <code>JSON::ParserError - A JSON text must at least contain two octets!</code> ，于此记录下问题。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="使用-CocoaPods-报错场景"><a href="#使用-CocoaPods-报错场景" class="headerlink" title="使用 CocoaPods 报错场景"></a>使用 CocoaPods 报错场景</h1><p>使用 CocoaPods 搜索一个库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod search &apos;xxx&apos;</span><br></pre></td></tr></table></figure></p><p>报错内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[!] Oh no, an error occurred.</span><br><span class="line"></span><br><span class="line">Search for existing GitHub issues similar to yours:</span><br><span class="line">https://github.com/CocoaPods/CocoaPods/search?q=A+JSON+text+must+at+least+contain+two+octets%21&amp;type=Issues</span><br><span class="line"></span><br><span class="line">If none exists, create a ticket, with the template displayed above, on:</span><br><span class="line">https://github.com/CocoaPods/CocoaPods/issues/new</span><br><span class="line"></span><br><span class="line">Be sure to first read the contributing guide for details on how to properly submit a ticket:</span><br><span class="line">https://github.com/CocoaPods/CocoaPods/blob/master/CONTRIBUTING.md</span><br><span class="line"></span><br><span class="line">Don&apos;t forget to anonymize any private data!</span><br><span class="line"></span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/sidekick.rb:91:in `block in validate_delegate&apos;: #&lt;Pod::UserInterface::InspectorReporter:0x007fa2940bf9d0&gt; does not handle inspector_successfully_recieved_report (RuntimeError)</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/sidekick.rb:90:in `each&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/sidekick.rb:90:in `validate_delegate&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/sidekick.rb:20:in `search&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/inspector.rb:65:in `search_query&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/gh_inspector-1.0.2/lib/gh_inspector/inspector.rb:59:in `search_exception&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/lib/cocoapods/user_interface/error_report.rb:119:in `search_for_exceptions&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/lib/cocoapods/command.rb:67:in `report_error&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:396:in `handle_exception&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:337:in `rescue in run&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:325:in `run&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/lib/cocoapods/command.rb:52:in `run&apos;</span><br><span class="line">from /usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/bin/pod:55:in `&lt;top (required)&gt;&apos;</span><br><span class="line">from /usr/local/bin/pod:22:in `load&apos;</span><br><span class="line">from /usr/local/bin/pod:22:in `&lt;main&gt;&apos;</span><br></pre></td></tr></table></figure></p><p>不常使用 <code>cmd</code> 的小伙伴，看到报错应该会感到蛋蛋的忧桑吧~~~</p><p><br></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>静静看看，错误报文已经给出两个建议：</p><ol><li><a href="https://github.com/CocoaPods/CocoaPods/search?q=A+JSON+text+must+at+least+contain+two+octets%21&amp;type=Issues" target="_blank" rel="noopener">搜索 github 已经存在的 issue</a></li><li><a href="https://github.com/CocoaPods/CocoaPods/issues/new" target="_blank" rel="noopener">如果没有已存在的 issue 使用模板创建一个新的 issue</a></li></ol><p>我们先试试搜索一下，是否存在相同的问题（是否有人踩过这个坑）。。。</p><p><img src="/resourse/iOS/Cocoapods/0.png" alt="img0"></p><p>oh my god~ 有两个，纳尼！怎么这两个报错的描述和标题与我的报错 <code>[!] Oh no, an error occurred.</code> 都不一样啊。</p><p>算了去搜索引擎搜一搜 <code>[!] Oh no, an error occurred.</code>吧，Baidu、Google后并没什么卵用，都是让删除本地Pod repo缓存重新下载，日哦，下载不要时间的啊。</p><p>不要慌，慢慢来。再仔细看看错误报文(Ps:前面还有一页错误信心描述，粗心累死了多少程序🐒啊！！！)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">――― MARKDOWN TEMPLATE ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br><span class="line"></span><br><span class="line">### Command</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/usr/local/bin/pod search AFN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Report</span><br><span class="line"></span><br><span class="line">* What did you do?</span><br><span class="line"></span><br><span class="line">* What did you expect to happen?</span><br><span class="line"></span><br><span class="line">* What happened instead?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Stack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   CocoaPods : 1.5.0</span><br><span class="line">        Ruby : ruby 2.3.3p222 (2016-11-21 revision 56859) [x86_64-darwin16]</span><br><span class="line">    RubyGems : 2.5.2</span><br><span class="line">        Host : Mac OS X 10.12.6 (16G1504)</span><br><span class="line">       Xcode : 9.0.1 (9A1004)</span><br><span class="line">         Git : git version 2.13.5 (Apple Git-94)</span><br><span class="line">Ruby lib dir : /usr/local/Cellar/ruby/2.3.3/lib</span><br><span class="line">Repositories : coding-kaistart-ksspecs - https://git.coding.net/kaistart/KSSpecs.git @ dc1bb74b7ac2e82345dc0992c671755888e91795</span><br><span class="line">               coding-pirate6-ksspecs - https://git.coding.net/pirate6/KSSpecs.git @ 941a46bfd3fb9c76966e7c6982bfccf028984bcf</span><br><span class="line">               kaistart-ios-ksspecs - http://gitlab.kaistart.net/iOS/KSSpecs.git @ 207791a83fc010410b4e46dbfedd2452068e154d</span><br><span class="line">               KSSpecs - git@git.coding.net:kaistart/KSSpecs.git @ dc1bb74b7ac2e82345dc0992c671755888e91795</span><br><span class="line">               KSZC - https://git.coding.net/pirate6/KSSpecs.git @ 941a46bfd3fb9c76966e7c6982bfccf028984bcf</span><br><span class="line">               master - https://github.com/CocoaPods/Specs.git @ a1c2e4450029d193bd8336d18577aff34c0136cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Plugins</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cocoapods-deintegrate : 1.0.2</span><br><span class="line">cocoapods-plugins     : 1.0.0</span><br><span class="line">cocoapods-search      : 1.0.0</span><br><span class="line">cocoapods-stats       : 1.0.0</span><br><span class="line">cocoapods-trunk       : 1.3.0</span><br><span class="line">cocoapods-try         : 1.1.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JSON::ParserError - A JSON text must at least contain two octets!</span><br><span class="line">/usr/local/Cellar/ruby/2.3.3/lib/ruby/2.3.0/json/common.rb:156:in `initialize&apos;</span><br><span class="line">/usr/local/Cellar/ruby/2.3.3/lib/ruby/2.3.0/json/common.rb:156:in `new&apos;</span><br><span class="line">/usr/local/Cellar/ruby/2.3.3/lib/ruby/2.3.0/json/common.rb:156:in `parse&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-core-1.5.0/lib/cocoapods-core/source/manager.rb:251:in `stored_search_index&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-core-1.5.0/lib/cocoapods-core/source/manager.rb:187:in `updated_search_index&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-core-1.5.0/lib/cocoapods-core/source/manager.rb:118:in `search_by_name&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-search-1.0.0/lib/cocoapods-search/command/search.rb:87:in `local_search&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-search-1.0.0/lib/cocoapods-search/command/search.rb:63:in `run&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/claide-1.0.2/lib/claide/command.rb:334:in `run&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/lib/cocoapods/command.rb:52:in `run&apos;</span><br><span class="line">/usr/local/lib/ruby/gems/2.3.0/gems/cocoapods-1.5.0/bin/pod:55:in `&lt;top (required)&gt;&apos;</span><br><span class="line">/usr/local/bin/pod:22:in `load&apos;</span><br><span class="line">/usr/local/bin/pod:22:in `&lt;main&gt;&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">――― TEMPLATE END ――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――</span><br></pre></td></tr></table></figure></p><p><img src="/resourse/iOS/Cocoapods/1.jpg" alt="img1"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JSON::ParserError - A JSON text must at least contain two octets!</span><br></pre></td></tr></table></figure><p>Nice，跟错误报文搜索到的 issue 完全匹配，去看看两个 issue 里的讨论。<br>找到解决办法了：<br><img src="/resourse/iOS/Cocoapods/2.png" alt="img2"></p><p>具体解决方案如下：</p><ol><li><code>cd ~/Library/Caches/CocoaPods/</code>看看是否存在<code>search_index.json</code>文件;</li><li>如果存在，看看<code>search_index.json</code>文件大小是否是0字节;</li><li>如果<code>search_index.json</code>文件大小是否是0字节，删除该文件，重新执行<code>pod search &#39;xxx&#39;</code>即可；</li></ol><p>CocoaPods 会重新创建 search_index.json 文件，会有如下输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Creating search index for spec repo &apos;coding-xxx-xxx&apos;.. Done!</span><br><span class="line">Creating search index for spec repo &apos;kaistart-ios-xxx&apos;.. Done!</span><br><span class="line">Creating search index for spec repo &apos;master&apos;.. Done!</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>去<code>CocoaPods</code>官网溜达一圈，原来<code>CocoaPods</code>在缓存策略在操作主机本地有二级缓存，一级在系统资源库的<code>Caches</code>目录下，第二级缓存在使用<code>CocoaPods</code>的工程目录下。</p><p>在执行<code>pod install</code>时，会先从本地缓存<code>copy</code>到工程目录下，再建立项目工程与项目目录下缓存的依赖关系，而从本地一级缓存查询就是利用这个搜索索引的json文件<code>search_index.json</code>，该json文件的内容就是一级缓存的目录。</p><p>每次更新仓库的时候<code>search_index.json</code>文件就会重新创建，出现<code>JSON::ParserError - A JSON text must at least contain two octets!</code>错误可能是因为在更新仓库的时候被打断了（或主动中断进程），所以Google到的通过重新更新仓库来解决这个问题，也是可以的。</p><p>但是国内的网络问题，更新起来很慢，故可以删除<code>search_index.json</code>文件，在使用<code>CocoaPods</code>命令<code>install</code>丨<code>search</code>等都会重新创建<code>search_index.json</code>文件，便可解决<code>JSON::ParserError - A JSON text must at least contain two octets!</code>问题。</p><p>终于告一段落，我佛慈悲，无量寿佛…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用 pod search ‘xxx’ 时报错 &lt;code&gt;JSON::ParserError - A JSON text must at least contain two octets!&lt;/code&gt; ，于此记录下问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>xcodebuild issue (2) —— EXPORT FAILED</title>
    <link href="http://wliu6.github.io/2017/05/03/iOS-compileIssue/"/>
    <id>http://wliu6.github.io/2017/05/03/iOS-compileIssue/</id>
    <published>2017-05-03T13:59:05.000Z</published>
    <updated>2021-04-21T08:59:21.059Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近使用 xcodebuild 打包时，报错<code>导出Archive无法找到method</code>，找到原因总结了一下，于此记录。</p></blockquote><a id="more"></a><hr><h1 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IDEDistribution: -[IDEDistributionLogging _createLoggingBundleAtPath:]: Created bundle at path &apos;/var/folders/qm/jnw7j5p13wn9pm1zt8wyvw6h0000gn/T/app-thermo-ios-swift_2015-09-20_07-30-24.286.xcdistributionlogs&apos;.  </span><br><span class="line">error: exportArchive: exportOptionsPlist error for key &apos;method&apos;: expected one of &#123;&#125;, but found ad-hoc  </span><br><span class="line">Error Domain=IDEFoundationErrorDomain Code=1 &quot;exportOptionsPlist error for key &apos;method&apos;: expected one of &#123;&#125;, but found ad-hoc&quot; UserInfo=0x7f865f953140 &#123;NSLocalizedDescription=exportOptionsPlist error for key &apos;method&apos;: expected one of &#123;&#125;, but found ad-hoc&#125;  </span><br><span class="line">** EXPORT FAILED **</span><br></pre></td></tr></table></figure><p>遇到报错，作为一名程序🐒的我，立马Google、Stack Overflow了一下，然而并没有卵用，搜到的几篇帖子并不能解决问题，心中一千万只草泥马呼啸而过啊，我是代码的搬运工啊，搜不到这可咋办。<br>呆毛一转，灵机一动，去<a href="https://developer.apple.com/search/" target="_blank" rel="noopener">Apple开发者中心</a>和搜了一下，终于找到了<a href="https://forums.developer.apple.com/message/59201#59201" target="_blank" rel="noopener">组织</a>，然而并没有解决问题的方案。不由感叹“撸码不易，且撸且珍惜啊”。<br>当初写脚本打包，目的是为了自动化且方便。可以直接根据configuration打不同配置连接不同server的包并上传piv，自动发提测邮件给测试团队（毕竟程序员都懒嘛，既然是重复活儿，当然自动化最好）。自己挖的坑得自己填啊，撸起袖子使劲儿干吧骚年。</p><h1 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h1><p>既然找不到答案，就分析下原因吧(Ps:&ensp;不然咋交差啊，饭碗重要啊)。报错信息中提到<code>exportOptionsPlist error for key &#39;method&#39;: expected one of {}, but found ad-hoc</code>。明显是打包脚本使用导出ipa的plist文件使用了无法识别的mothod。查下文档吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -help</span><br></pre></td></tr></table></figure></p><p>节选出<code>-exportOptionsPlist</code>option的method相关部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method : String</span><br><span class="line"></span><br><span class="line">Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, developer-id, and mac-application. The list of options varies based on the type of archive. Defaults to development.</span><br></pre></td></tr></table></figure></p><p>但是明明xcodebuild的使用文档中通过的method可用参数包含ad-hoc。为啥导出会出错呢？<br>将compile输出的xxx.xcarchive的文件使用Xcode打开，<br><img src="/resourse/iOS/CompileIssue/0.png" alt="img0"></p><p>为什么会是无法识别类型呢？<br>打开Xcode，看看Build Settings，<br><img src="/resourse/iOS/CompileIssue/1.png" alt="img1"><br>会发现在archivectures有一个Base SDK的可选项，可选的option都是编译依赖的框架版本，有mac的，有iOS的，有watchOS的，也有tvOS的，等等。<br>查看脚本中compile过程执行cmd如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild archive -workspace $project_name.xcworkspace \</span><br><span class="line">-scheme $scheme_name \</span><br><span class="line">-configuration $config_name \</span><br><span class="line">-archivePath $outputpath/$project_name.xcarchive \</span><br></pre></td></tr></table></figure></p><p>并没有使用xcodebuild的-sdk option，试着加一下这个option看看能否解决问题。将修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild archive -workspace $project_name.xcworkspace \</span><br><span class="line">-scheme $scheme_name \</span><br><span class="line">-configuration $config_name \</span><br><span class="line">-archivePath $outputpath/$project_name.xcarchive \</span><br><span class="line">-sdk $CURRENT_EQUIPMENT_iOS_SDK</span><br></pre></td></tr></table></figure></p><p>Oh my god~！成功了！</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你遇到同样的错误，可以在这里找到解决方案。</p><p>使用xcodebuild打包，需要执行两个步骤：</p><ol><li>编译生成.xcarchive包</li><li>导出ipa</li></ol><p>分析问题步骤发现，在步骤1的命令添加-sdk option就可以完美解决问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild archive -workspace your_workspace -scheme your_scheme_name -configuration your_config_name -archivePath outputpath/your_project_name.xcarchive -sdk your_appoint_sdk</span><br></pre></td></tr></table></figure></p><p>sdk option可接收的参数可以使用如下命令查看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -showsdks</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近使用 xcodebuild 打包时，报错&lt;code&gt;导出Archive无法找到method&lt;/code&gt;，找到原因总结了一下，于此记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>xcodebuild issue (1) —— unable to find utility &quot;PackageApplication&quot;</title>
    <link href="http://wliu6.github.io/2017/01/05/iOS-compileIssue-1/"/>
    <id>http://wliu6.github.io/2017/01/05/iOS-compileIssue-1/</id>
    <published>2017-01-05T08:10:04.000Z</published>
    <updated>2021-04-21T08:59:21.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>更新到Xcode8.3之后发现，之前的打包脚本不能用了，不能用了。<br>本文介绍如何解该问题。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="脚本报错信息"><a href="#脚本报错信息" class="headerlink" title="脚本报错信息"></a>脚本报错信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun: error: unable to find utility &quot;PackageApplication&quot;, not a developer tool or in PATH</span><br></pre></td></tr></table></figure><p><br></p><h1 id="分析原因并解决"><a href="#分析原因并解决" class="headerlink" title="分析原因并解决"></a>分析原因并解决</h1><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>无法找到”PackageApplication”，想了是不是把这个软件放到该目录下就可以了。先去找个旧版的Xcode里面copy一份过来<br>放到下面这个目录：<br><code>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/</code><br>继续<code>xcrun</code>，发现PackageApplication无法执行，给个执行权限就好了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer/</span><br><span class="line">$ chmod +x /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/usr/bin/PackageApplication</span><br></pre></td></tr></table></figure></p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>后来查了下文档，发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PackageApplication is removed from Xcode 8.3.</span><br></pre></td></tr></table></figure></p><p>在强行使用<code>PackageApplication</code>的话不太友好。Apple推荐Xcode&ensp;8.3之后使用xcodebuild导出.ipa文件。将导入.ipa文件的是cmd换成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild \</span><br><span class="line">-exportArchive \</span><br><span class="line">-archivePath &quot;$&#123;PROJECT_BUILDDIR&#125;/$&#123;SCHEME_NAME&#125;.xcarchive&quot; \</span><br><span class="line">-exportPath &quot;$&#123;BUILD_OUTPUT_DIR&#125;&quot;</span><br></pre></td></tr></table></figure><p>发现汇报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild: error: The flag -exportOptionsPlist is required when specifying -exportArchive.</span><br></pre></td></tr></table></figure></p><p>原来通过.xcarchive导出.ipa，有一个必要参数-exportOptionsPlist，改成如下，便可成功打包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xcodebuild \</span><br><span class="line">-exportArchive \</span><br><span class="line">-archivePath &quot;$&#123;PROJECT_BUILDDIR&#125;/$&#123;SCHEME_NAME&#125;.xcarchive&quot; \</span><br><span class="line">-exportOptionsPlist &quot;$&#123;EXPORT_PLIST&#125;&quot; \</span><br><span class="line">-exportPath &quot;$&#123;BUILD_OUTPUT_DIR&#125;&quot;</span><br></pre></td></tr></table></figure></p><p>但是这个option的参数是啥？<br>直接看文档吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xcodebuild -help</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"># -exportOptionsPlist 参数说明</span><br><span class="line">-exportOptionsPlist PATH    specifies a path to a plist file that configures archive exporting</span><br><span class="line"></span><br><span class="line"># plist 文件的参数说明如下</span><br><span class="line">Available keys for -exportOptionsPlist:</span><br><span class="line"></span><br><span class="line">compileBitcode : Bool</span><br><span class="line"></span><br><span class="line">For non-App Store exports, should Xcode re-compile the app from bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">embedOnDemandResourcesAssetPacksInBundle : Bool</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and this is YES, asset packs are embedded in the app bundle so that the app can be tested without a server to host asset packs. Defaults to YES unless onDemandResourcesAssetPacksBaseURL is specified.</span><br><span class="line"></span><br><span class="line">iCloudContainerEnvironment : String</span><br><span class="line"></span><br><span class="line">If the app is using CloudKit, this configures the &quot;com.apple.developer.icloud-container-environment&quot; entitlement. Available options vary depending on the type of provisioning profile used, but may include: Development and Production.</span><br><span class="line"></span><br><span class="line">installerSigningCertificate : String</span><br><span class="line"></span><br><span class="line">For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are &quot;Mac Installer Distribution&quot; and &quot;Developer ID Installer&quot;. Defaults to an automatic certificate selector matching the current distribution method.</span><br><span class="line"></span><br><span class="line">manifest : Dictionary</span><br><span class="line"></span><br><span class="line">For non-App Store exports, users can download your app over the web by opening your distribution manifest file in a web browser. To generate a distribution manifest, the value of this key should be a dictionary with three sub-keys: appURL, displayImageURL, fullSizeImageURL. The additional sub-key assetPackManifestURL is required when using on-demand resources.</span><br><span class="line"></span><br><span class="line">method : String</span><br><span class="line"></span><br><span class="line">Describes how Xcode should export the archive. Available options: app-store, ad-hoc, package, enterprise, development, developer-id, and mac-application. The list of options varies based on the type of archive. Defaults to development.</span><br><span class="line"></span><br><span class="line">onDemandResourcesAssetPacksBaseURL : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, if the app uses On Demand Resources and embedOnDemandResourcesAssetPacksInBundle isn&apos;t YES, this should be a base URL specifying where asset packs are going to be hosted. This configures the app to download asset packs from the specified URL.</span><br><span class="line"></span><br><span class="line">provisioningProfiles : Dictionary</span><br><span class="line"></span><br><span class="line">For manual signing only. Specify the provisioning profile to use for each executable in your app. Keys in this dictionary are the bundle identifiers of executables; values are the provisioning profile name or UUID to use.</span><br><span class="line"></span><br><span class="line">signingCertificate : String</span><br><span class="line"></span><br><span class="line">For manual signing only. Provide a certificate name, SHA-1 hash, or automatic selector to use for signing. Automatic selectors allow Xcode to pick the newest installed certificate of a particular type. The available automatic selectors are &quot;Mac App Distribution&quot;, &quot;iOS Developer&quot;, &quot;iOS Distribution&quot;, &quot;Developer ID Application&quot;, and &quot;Mac Developer&quot;. Defaults to an automatic certificate selector matching the current distribution method.</span><br><span class="line"></span><br><span class="line">signingStyle : String</span><br><span class="line"></span><br><span class="line">The signing style to use when re-signing the app for distribution. Options are manual or automatic. Apps that were automatically signed when archived can be signed manually or automatically during distribution, and default to automatic. Apps that were manually signed when archived must be manually signed during distribtion, so the value of signingStyle is ignored.</span><br><span class="line"></span><br><span class="line">stripSwiftSymbols : Bool</span><br><span class="line"></span><br><span class="line">Should symbols be stripped from Swift libraries in your IPA? Defaults to YES.</span><br><span class="line"></span><br><span class="line">teamID : String</span><br><span class="line"></span><br><span class="line">The Developer Portal team to use for this export. Defaults to the team used to build the archive.</span><br><span class="line"></span><br><span class="line">thinning : String</span><br><span class="line"></span><br><span class="line">For non-App Store exports, should Xcode thin the package for one or more device variants? Available options: &lt;none&gt; (Xcode produces a non-thinned universal app), &lt;thin-for-all-variants&gt; (Xcode produces a universal app and all available thinned variants), or a model identifier for a specific device (e.g. &quot;iPhone7,1&quot;). Defaults to &lt;none&gt;.</span><br><span class="line"></span><br><span class="line">uploadBitcode : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include bitcode? Defaults to YES.</span><br><span class="line"></span><br><span class="line">uploadSymbols : Bool</span><br><span class="line"></span><br><span class="line">For App Store exports, should the package include symbols? Defaults to YES.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;更新到Xcode8.3之后发现，之前的打包脚本不能用了，不能用了。&lt;br&gt;本文介绍如何解该问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods —— 创建私有库</title>
    <link href="http://wliu6.github.io/2016/07/20/cocoapods-private-repo-md/"/>
    <id>http://wliu6.github.io/2016/07/20/cocoapods-private-repo-md/</id>
    <published>2016-07-20T05:36:29.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文介绍如何创建<code>CocoaPods</code>私有库，适合使用<code>CocoaPods</code>私有库。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="创建CocoaPods私有库"><a href="#创建CocoaPods私有库" class="headerlink" title="创建CocoaPods私有库"></a>创建CocoaPods私有库</h1><p>业务需求，需要开发一些iOS的私有功能repo，供组织内部使用，并不对外开源，汇总了一下<code>CocoaPods</code>私有库的相关内容。</p><h2 id="创建library"><a href="#创建library" class="headerlink" title="创建library"></a>创建library</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib create &lt;repo-name&gt;</span><br></pre></td></tr></table></figure><pre><code>What platform do you want to use?? [ iOS / macOS ]iOSWhat language do you want to use?? [ Swift / ObjC ]ObjCWould you like to provide a demo application with your library? [ Yes / No ]yesWhich testing frameworks will you use? [ Specta / Kiwi / None ]KiwiWould you like to do view based testing? [ Yes / No ]NoWhat is your class prefix?BZ</code></pre><p>简单介绍一下创建时可选项，第一个是想要使用的平台，第二个是想要使用的编程语言，第三个是是否为你的<code>library</code>创建一个<code>demo</code>工程；第四个是选择一个你习惯使用的单元测试框架，提供了两个常用的<code>BDD</code>框架；第五个是是否使用非死不可的<code>FBSnapshotTestCase</code>UI测试框架；第六个是设置一个类目前缀。</p><h2 id="修改-podspec文件的信息"><a href="#修改-podspec文件的信息" class="headerlink" title="修改.podspec文件的信息"></a>修改.podspec文件的信息</h2><p>执行<code>pod lib create</code>命令会自动生成.podspec文件，是一个配置文件。新生成的<code>.podspec</code>包含所有参数，<code>.podspec</code>文件中有每个参数的注释。实际使用时，需要进行裁剪。常用的有</p><pre><code>1. name —— library的名字；2. version —— library的版本号；3. summary —— library的简介；4. platform —— library支持的平台；5. source —— library的源码引用；6. license —— library的开源协议；...</code></pre><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line">  s.name         = &quot;KSZCMediateRouter&quot;</span><br><span class="line">  s.version      = &quot;0.1.0&quot;</span><br><span class="line">  s.summary      = &quot;路由中间件，target通信中介者.&quot;</span><br><span class="line">  s.platform     = :ios, &apos;6.0&apos;</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">                    提供组件间通信，使用成本极低，支持常量参数，支持直接调用类方法。</span><br><span class="line">                   DESC</span><br><span class="line">  s.homepage     = &quot;https://www.kaishiba.com/&quot;</span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;GPL&quot;, :file =&gt; &quot;./LICENSE&quot; &#125;</span><br><span class="line">  s.author       = &quot;wliu6&quot;</span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;http://gitlab.kaistart.net/iOS/KSZCMediateRouter.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line">  s.prefix_header_contents = &apos;#import &lt;Foundation/Foundation.h&gt;&apos;</span><br><span class="line">  s.source_files  = &quot;KSZCMediateRouter/**/*.&#123;h,m&#125;&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="上传CocoaPods私有库"><a href="#上传CocoaPods私有库" class="headerlink" title="上传CocoaPods私有库"></a>上传CocoaPods私有库</h1><h2 id="添加repo"><a href="#添加repo" class="headerlink" title="添加repo"></a>添加repo</h2><p>由于开发的是私有库，所以不会打包上传到<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">CocoaPods Public Specs Repo</a>，而是上传到<code>Private Specs Repo</code>。添加私有repo，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod repo add &lt;specs-name&gt; &lt;specs-repo-url&gt;</span><br></pre></td></tr></table></figure></p><p>如果还没有<code>Private Specs Repo</code>，建立一个空的<code>git repo</code>即可</p><h2 id="验证library"><a href="#验证library" class="headerlink" title="验证library"></a>验证library</h2><p>开发完成静态类库之后，需要验证一下类库是否符合要求（能否编译通过）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod lib lint xxx.podspec</span><br></pre></td></tr></table></figure></p><p>常用option：</p><table><thead><tr><th>option</th><th>用途</th></tr></thead><tbody><tr><td>--verbose</td><td>输出更详细的验证报告。</td></tr><tr><td>--use-libraries</td><td>有引用静态库时使用，不然通不过验证。（验证过程默认认为library没有引用静态库）</td></tr><tr><td>--only-errors</td><td>验证过程忽略警告（version&lt;1.0.0）。</td></tr><tr><td>--allow-warnings</td><td>验证过程忽略警告（version&gt;=1.0.0）。</td></tr><tr><td>--sources=master,<your-source></your-source></td><td>library使用的源（如果library引用了私有源的库，必须传入源参数）。</td></tr></tbody></table><h2 id="上传library"><a href="#上传library" class="headerlink" title="上传library"></a>上传library</h2><p>验证后，上传直接执行如下命令即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo push &lt;specs-name&gt; xxx.podspec</span><br></pre></td></tr></table></figure><p>常用option：</p><table><thead><tr><th>option</th><th>用途</th></tr></thead><tbody><tr><td>--verbose</td><td>输出更详细的验证报告。</td></tr><tr><td>--use-libraries</td><td>有引用静态库时使用，不然通不过验证。（验证过程默认认为library没有引用静态库）</td></tr><tr><td>--only-errors</td><td>验证过程忽略警告（version&lt;1.0.0）。</td></tr><tr><td>--allow-warnings</td><td>验证过程忽略警告（version&gt;=1.0.0）。</td></tr><tr><td>--sources=master,<your-source></your-source></td><td>library使用的源（如果library引用了私有源的库，必须传入源参数）。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文介绍如何创建&lt;code&gt;CocoaPods&lt;/code&gt;私有库，适合使用&lt;code&gt;CocoaPods&lt;/code&gt;私有库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS Variable Argument</title>
    <link href="http://wliu6.github.io/2016/06/12/iOS-VariableParams/"/>
    <id>http://wliu6.github.io/2016/06/12/iOS-VariableParams/</id>
    <published>2016-06-12T12:08:00.000Z</published>
    <updated>2021-04-21T08:59:21.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>iOS的可变参数本质上是C语言特性，也就是说类C语言都可用使用，只需导入头文件<code>#include &lt;stdarg.h&gt;</code>。本文将以Objective-C来介绍什么是可变参数，如何使用可变参数，以及可变参数如何传递。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="什么是可变参数"><a href="#什么是可变参数" class="headerlink" title="什么是可变参数"></a>什么是可变参数</h1><p>可变参数只能作为函数的最后一个参数，<code>...</code>前<code>,</code>隔开的参数就是可变参数，可变参数本质上是一个参数指针，每一次取参后指针地址位移，指向下一个参数的内存地址，知道指向野指针(nil)为止。使用时多个参数以<code>,</code>隔开。</p><p>下面例子中的format参数便是一个可变参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)stringWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2);</span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NSString stringWithFormat:@&quot;项目结束时间: %@\n%@\n开奖时间: %@\n%@\n大盘指数来源交易日: %@\n%@\n上证指数: %@\n%@\n深证指数: %@\n%@\n档位认筹人数: %@\n%@\n抽奖规则: %@\n%@\n中奖名额: %@\n%@\n抽奖码个数: %@&quot;,[dic ks_objectForKey:@&quot;time&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;lotteryTime&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;date&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;shse&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;size&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;num&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;rule&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;winnerNum&quot; replace:@&quot;&quot;],@&quot;&quot;,[dic ks_objectForKey:@&quot;lotteryCodeNum&quot; replace:@&quot;&quot;]];</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="可变参数如何解析多个参数"><a href="#可变参数如何解析多个参数" class="headerlink" title="可变参数如何解析多个参数"></a>可变参数如何解析多个参数</h1><p>可变参数实际上是利用几个C语言的宏来实现参数解析，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _VA_LIST</span><br><span class="line">typedef __builtin_va_list va_list;</span><br><span class="line">#define _VA_LIST</span><br><span class="line">#endif</span><br><span class="line">#define va_start(ap, param) __builtin_va_start(ap, param)</span><br><span class="line">#define va_end(ap)          __builtin_va_end(ap)</span><br><span class="line">#define va_arg(ap, type)    __builtin_va_arg(ap, type)</span><br></pre></td></tr></table></figure></p><ol><li><code>va_list</code> —— 指向可变参数的指针；</li><li><code>va_start(ap, param)</code> —— 开始读取可变参数列表；</li><li><code>va_start(ap, param)</code> —— 结束读取可变参数列表；</li><li><code>va_arg(ap, type)</code> —— 读取参数(每读取一次，参数列表指针将指向下一个参数的内存地址)；</li></ol><p><br></p><h1 id="实现可变参数函数"><a href="#实现可变参数函数" class="headerlink" title="实现可变参数函数"></a>实现可变参数函数</h1><h2 id="参数为Objective-C对象"><a href="#参数为Objective-C对象" class="headerlink" title="参数为Objective-C对象"></a>参数为Objective-C对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)writeWithFormat:(NSObject *)string, ... NS_REQUIRES_NIL_TERMINATION;</span><br><span class="line"></span><br><span class="line">- (void)writeWithFormat:(NSObject *)string, ... &#123;</span><br><span class="line">  // 定义一个指向个数可变的参数列表指针；</span><br><span class="line">  va_list args; </span><br><span class="line">  va_start(args, string);</span><br><span class="line">  if (string) &#123;</span><br><span class="line">    NSLog(@&quot;Do something with First: %@&quot;, string);</span><br><span class="line">    NSObject *other;</span><br><span class="line">    // 依次取得除第一个参数以外的参数</span><br><span class="line">    while ((other = va_arg(args, NSObject *))) &#123;</span><br><span class="line">      NSLog(@&quot;Do something with other: %@&quot;, other);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 清空参数列表，并置参数指针args无效。</span><br><span class="line">  va_end(args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数为scalar或struct对象"><a href="#参数为scalar或struct对象" class="headerlink" title="参数为scalar或struct对象"></a>参数为scalar或struct对象</h2><p>实现参数为常量或者结构体的可变参数函数，实现方法和参数为Objective-C一样，此处不赘述。</p><h2 id="任意参数类型"><a href="#任意参数类型" class="headerlink" title="任意参数类型"></a>任意参数类型</h2><p>因为Variable Argument是C语言特性，所以参数可以是C指针，可以利用C指针指向内存地址的特性来实现任意参数类型的可变参数函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)method:(void *)arguments, ... NS_REQUIRES_NIL_TERMINATION;</span><br><span class="line"></span><br><span class="line">- (void)method:(void *)arguments, ... &#123;</span><br><span class="line">  va_list args; </span><br><span class="line">  va_start(args, arguments);</span><br><span class="line">  if (arguments) &#123;</span><br><span class="line">    void *other = ;</span><br><span class="line">    while ((other = va_arg(args, void *))) &#123;</span><br><span class="line">      // use arguments to do sth</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(args); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用场景：<a href>优化performSelector函数</a></p><p>但是获取到的C指针如何处理呢？<br>可以使用<a href>@encode()</a>获取编码类型，然后__bridge一下^_^。</p><h2 id="可变参数传参"><a href="#可变参数传参" class="headerlink" title="可变参数传参"></a>可变参数传参</h2><p>由于可变参数，在运行时才可以确定参数列表。传参时会发现，如果将可变参数当做普通指针参数传递的话，接收参数的函数只能拿到可变参数指针指向的第一个参数。那么如何进行可变参数传参呢？</p><p>可变参数传参需要一个迂回的操作，前文有提到va_list是可变参数参数指针，可以传参的时候顺道把指针丢过去即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)xxxParams:(void *)params, ...</span><br><span class="line">&#123;</span><br><span class="line">  va_list args; </span><br><span class="line">  va_start(args, params);</span><br><span class="line">  [self testParams:params args:args];</span><br><span class="line">  va_end(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)testParams:(void *)params args:(va_list)args &#123;</span><br><span class="line">  void *tmp;</span><br><span class="line">  while ((tmp = va_arg(args, void *))) &#123;</span><br><span class="line">    // to do sth</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;iOS的可变参数本质上是C语言特性，也就是说类C语言都可用使用，只需导入头文件&lt;code&gt;#include &amp;lt;stdarg.h&amp;gt;&lt;/code&gt;。本文将以Objective-C来介绍什么是可变参数，如何使用可变参数，以及可变参数如何传递。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>大话KVC</title>
    <link href="http://wliu6.github.io/2016/05/30/iOS-KVC/"/>
    <id>http://wliu6.github.io/2016/05/30/iOS-KVC/</id>
    <published>2016-05-30T03:23:06.000Z</published>
    <updated>2021-04-21T08:59:21.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文意在解释KVC原理，使用KVC并不会调用属性set方法，本文也会告知读者如何优化KVC。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="KVC-使用"><a href="#KVC-使用" class="headerlink" title="KVC 使用"></a>KVC 使用</h1><p>KVC（Key-value coding），键值编码。利用遵循非正式协议NSKeyValueCoding的对象，可以通过key-value关系访问对象的ivar列表。KVO、Core Data、Cocoa bindings、AppleScript均是基于KVC实现的。</p><p>提供了如下方法进行调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Objective-C</span><br><span class="line">- (nullable id)valueForKey:(NSString *)key;</span><br><span class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key; </span><br><span class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</span><br><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">// swift</span><br><span class="line">// 苹果在Swift 4 中苹果修改了自动添加 @objc 的逻辑，在使用KVC时记得添加</span><br><span class="line">open func value(forKey key: String) -&gt; Any?</span><br><span class="line">open func setValue(_ value: Any?, forKey key: String)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="KVC-原理"><a href="#KVC-原理" class="headerlink" title="KVC 原理"></a>KVC 原理</h1><p>使用KVC设置对象成员变量的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[obj setValue:ValueObject forKey:@&quot;InstanceKey&quot;];</span><br></pre></td></tr></table></figure></p><p>KVC基于runtime，要解释KVC原理，却繁之又繁，为节省读者理解作者语义的时间，下面便使用runtime实现KVC赋值的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">id value = NSObject.new;</span><br><span class="line">Class class = objc_getClass(&quot;TmpObject&quot;);</span><br><span class="line">id object = class_createInstance(class, class_getInstanceSize(class));</span><br><span class="line">Ivar ivar = class_getInstanceVariable(class, &quot;instance_name&quot;);</span><br><span class="line">object_setIvar(object, ivar, value);</span><br></pre></td></tr></table></figure><p>使用KVC时会发现一个严重的问题，给属性赋值时，override set方法不会被invoke，那么该如何解决这个问题呢？</p><p>可以用<code>objc_msgSend(void /* id self, SEL op, ... */ )</code>在设置成员变量值时，直接调用SEL。但是由于该函数被限制，使用时会如下警告:<br><img src="/resourse/iOS/KVC/0.png" style="margin-left:0px" width="1080"></p><p>但是我们可以退而求其次，使用<code>- (id)performSelector:(SEL)aSelector withObject:(id)object;</code>也可以打到我们的预期效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)optimizedCSetValue:(id)value forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    if (key.length == 0) return;</span><br><span class="line">    NSString *prefix = [key substringToIndex:1].uppercaseString;</span><br><span class="line">    NSString *subkey = [key substringFromIndex:1];</span><br><span class="line">    NSString *selName = [NSString stringWithFormat:@&quot;set%@%@:&quot;, prefix, subkey];</span><br><span class="line">    SEL sel = NSSelectorFromString(selName);</span><br><span class="line">    NSAssert([self respondsToSelector:sel], @&quot;当前对象不能响应该方法&quot;);</span><br><span class="line">    [obj performSelectorInBackground:sel withObject:value];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是该方法值只能对id类型的属性赋值，并执行属性的set方法。如果是scalar和struct类型的属性，难道就无计可施了吗？</p><p>66给你指条明路，就是使用NSIvocation来实现，NSIvocation的<code>- (void)setArgument:(void *)argumentLocation atIndex:(NSInteger)idx;</code>方法可以实现赋值任意类型<code>属性</code>的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)optimizedCSetValue:(void *)value forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    if (!key) return;</span><br><span class="line">    if (key.length == 0) return;</span><br><span class="line">    NSString *prefix = [key substringToIndex:1].uppercaseString;</span><br><span class="line">    NSString *subkey = [key substringFromIndex:1];</span><br><span class="line">    NSString *selName = [NSString stringWithFormat:@&quot;set%@%@:&quot;, prefix, subkey];</span><br><span class="line">    SEL sel = NSSelectorFromString(selName);</span><br><span class="line">    NSAssert([self respondsToSelector:sel], @&quot;当前对象不能响应该方法&quot;);</span><br><span class="line">    if (![self respondsToSelector:sel]) return;</span><br><span class="line">    NSMethodSignature *ms = [self methodSignatureForSelector:sel];</span><br><span class="line">    NSInvocation *inv = [NSInvocation invocationWithMethodSignature:ms];</span><br><span class="line">    [inv setTarget:self];</span><br><span class="line">    [inv setSelector:sel];</span><br><span class="line">    [inv setArgument:value atIndex:2];</span><br><span class="line">    [inv invoke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文意在解释KVC原理，使用KVC并不会调用属性set方法，本文也会告知读者如何优化KVC。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>hexo 使用图片</title>
    <link href="http://wliu6.github.io/2016/05/21/hexo-image/"/>
    <id>http://wliu6.github.io/2016/05/21/hexo-image/</id>
    <published>2016-05-21T10:14:11.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用hexo编辑bolg，需要使用markdown主要语言来编写。mark是一种标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>在使用github时，repo简介说明文件——README.md文件，便是使用markdown编辑的。我在初次使用hexo编辑blog时，插入图片遇到一些问题，解决问题后，便书于此文。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="Markdown-使用图片"><a href="#Markdown-使用图片" class="headerlink" title="Markdown 使用图片"></a>Markdown 使用图片</h1><p>markdown插入图片代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![tmpimage](/path/to/you/image_asset/image)</span><br></pre></td></tr></table></figure></p><p>效果如下:<br><img src="/resourse/hexo/image/0.jpg" alt="img0"></p><p>在某些markdown编辑器(例如: MWeb)上，可以对图片进行更多操作。</p><p>修改图片宽度，只需要在图片描述后添加”-w”+”宽度”，即可修改宽度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 图片宽度已经被修改为66，高度会等比缩放</span><br><span class="line">![tmpimage-w66](/path/to/you/image_asset/image)</span><br></pre></td></tr></table></figure></p><p>修改图片水平方向的队列布局方式，字需要在图片描述后添加”-l”或”-r”或”-c”，即可修改队列布局方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 居中显示</span><br><span class="line">![tmpimage-c](/path/to/you/image_asset/image)</span><br></pre></td></tr></table></figure></p><p>布局修饰与渲染效果对应关系如下表：</p><table><thead><tr><th>布局修饰</th><th>图片渲染效果</th></tr></thead><tbody><tr><td>-l</td><td>靠左显示</td></tr><tr><td>-c</td><td>居中显示</td></tr><tr><td>-r</td><td>靠右显示</td></tr></tbody></table><p>Note：<br><code>1.以上语法糖可一起使用;</code><br><code>2.但github等git repo网站为编辑文档使用markdown plugin并不支持这些操作图片的语法糖，hexo使用的markdown插件也不支持操作图片的语法糖;</code></p><p><br></p><h1 id="hexo-使用图片"><a href="#hexo-使用图片" class="headerlink" title="hexo 使用图片"></a>hexo 使用图片</h1><p>使用hexo搭建的博客，在编辑博客是插入图片却发现只能使用图片资源url。由于使用github page部署的静态站点，导致source下的图片无法直接当做文件资源通过url引用。但是又不想维护自己的图片资源server，安装hexo-asset-image插件便可以解决这个问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 该插件可以直接引用相对路径资源</span></span><br><span class="line">$ npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure></p><p>在对于这些无法使用修饰图片的语法糖的markdown解释器，也可以直接通过img标签来修改图片的渲染效果。</p><p>修改图片宽高，使用height、width即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/path/to/you/image_asset/image&quot; height=&quot;330&quot; width=&quot;495&quot;&gt;</span><br></pre></td></tr></table></figure></p><p><img src="/resourse/hexo/image/2.jpg" width="200"></p><p>同理修改图片布局，使用style即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/path/to/you/image_asset/image&quot; style=&quot;margin-left:0px&quot; height=&quot;70&quot; &gt;</span><br></pre></td></tr></table></figure></p><p><img src="/resourse/hexo/image/1.jpg" style="margin-left:0px" width="320"></p><p><br><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用hexo编辑bolg，需要使用markdown主要语言来编写。mark是一种标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。&lt;br&gt;在使用github时，repo简介说明文件——README.md文件，便是使用markdown编辑的。我在初次使用hexo编辑blog时，插入图片遇到一些问题，解决问题后，便书于此文。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="blog" scheme="http://wliu6.github.io/categories/blog/"/>
    
    
      <category term="hexo" scheme="http://wliu6.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>hexo搭建博客</title>
    <link href="http://wliu6.github.io/2016/05/02/hexo-initialize/"/>
    <id>http://wliu6.github.io/2016/05/02/hexo-initialize/</id>
    <published>2016-05-02T00:49:21.000Z</published>
    <updated>2021-04-21T08:59:21.058Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文讲述如何使用“hexo” + “GitHub Page”搭建自己的博客。<br><img src="/resourse/hexo/initialize/0.jpg" alt="img0"></p></blockquote><a id="more"></a><hr><p><br></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="Dependencies"><a href="#Dependencies" class="headerlink" title="Dependencies"></a>Dependencies</h2><ol><li>node</li><li>git（使用Mac、Ubuntu等自带git的操作系统不用处理）</li><li>GitHub</li></ol><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><ol><li>register domain</li></ol><!-- 文章主体开始 --><p><br></p><h1 id="创建GitHub-page仓库"><a href="#创建GitHub-page仓库" class="headerlink" title="创建GitHub page仓库"></a>创建GitHub page仓库</h1><p>使用“hexo” + “GitHub Page”搭建博客，首先需要一个GitHub Page repo。<br><img src="/resourse/hexo/initialize/1.png" alt="img1"><img src="/resourse/hexo/initialize/2.png" alt="img2"></p><p><br></p><h1 id="Blog-Compiling"><a href="#Blog-Compiling" class="headerlink" title="Blog Compiling"></a>Blog Compiling</h1><h2 id="全局安装hexo"><a href="#全局安装hexo" class="headerlink" title="全局安装hexo"></a>全局安装hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化hexo工程"><a href="#初始化hexo工程" class="headerlink" title="初始化hexo工程"></a>初始化hexo工程</h2><p>Node和Git都安装好后，首先创建一个文件夹，用于存放hexo的工程文件，然后进入该文件夹里初始化Hexo工程。由于在Mac下使用npm安装hexo，会自动关联安装hexo-cli，可以直接使用命令行工具进行初始化：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure></p><p>文件夹下目录结构入下<br><img src="/resourse/hexo/initialize/3.png" alt="img3"></p><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 常用命令</span><br><span class="line">$ hexo help # 查看帮助</span><br><span class="line">$ hexo new &quot;blog_name&quot; # 新建文章</span><br><span class="line">$ hexo new page &quot;page_name&quot; # 新建页面</span><br><span class="line">$ hexo generate # 生成静态页面至public目录</span><br><span class="line">$ hexo server # 开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）</span><br><span class="line">$ hexo deploy # 部署到GitHub</span><br><span class="line">$ hexo version # 查看Hexo的版本</span><br><span class="line"></span><br><span class="line"># 命令缩写</span><br><span class="line">hexo n &gt;&gt; hexo new</span><br><span class="line">hexo g &gt;&gt; hexo generate</span><br><span class="line">hexo s &gt;&gt; hexo server</span><br><span class="line">hexo d &gt;&gt; hexo deploy</span><br><span class="line"></span><br><span class="line"># 命令组合</span><br><span class="line">$ hexo s -g #生成并本地预览</span><br><span class="line">$ hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>_config.yml是博客样式的配置文件，文件中的注释已经说明每个参数的用途，再次不做缀述，实在不懂的可去 <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">hexo</a> 官网查看configuration文档。编辑 _config.yml 的时候需要注意一下两点：</p><ol><li><strong>冒号后面必须有一个空格，否则hexo可能会出问题。</strong></li><li><strong>每次编辑完_config.yml之后，记得校验一下YAML文件格式，可以使用脚本或者YAML online。如果YAML文件格式报错，会导致hexo命令执行时报错。</strong></li></ol><h2 id="编写blog"><a href="#编写blog" class="headerlink" title="编写blog"></a>编写blog</h2><p>进入hexo工程根目录，创建一篇新博文：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;blog_name&quot;</span><br></pre></td></tr></table></figure></p><p>hexo-cli会echo博文所在物理路径：<br><img src="/resourse/hexo/initialize/4.png" alt="img4"><br>接下来编辑的博客就可以了（编辑博客使用markdown语法），可以直接使用EMACS或者Vim，当然也可以用你常用的编辑器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ emacs ~/work/hexo/source/_posts/hexo-initialize.md</span><br></pre></td></tr></table></figure></p><h2 id="部署bolg"><a href="#部署bolg" class="headerlink" title="部署bolg"></a>部署bolg</h2><h3 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h3><p><strong>通过GitHub进行部署需要使用ssh方案（根据hexo官方文档，deploy并不支持GitHub的https方案）。</strong></p><p>检查本机已生成过ssh密钥<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/. ssh</span><br></pre></td></tr></table></figure></p><p>如果有，直接copy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub |pbcopy</span><br></pre></td></tr></table></figure></p><p>如果没有，生成SSH Key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;#email#&quot;</span><br></pre></td></tr></table></figure></p><p>再进行copy，然后将复制ssh公钥配置到你的GitHub。<br><img src="/resourse/hexo/initialize/5.png" alt="img5"><img src="/resourse/hexo/initialize/6.png" alt="img6"><img src="/resourse/hexo/initialize/7.png" alt="img7"></p><p>检测是否SSH Key是否配置成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>如提示<br><code>Are you sure you want to continue connecting (yes/no)?</code><br>输入yes，配置成功输出：<br><code>Hi liuxianan! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</code><br>失败则会挂起当前执行进程，<code>Clt</code>+<code>c</code>退出即可。</p><h3 id="config-hexo-deployment"><a href="#config-hexo-deployment" class="headerlink" title="config hexo deployment"></a>config hexo deployment</h3><p>由于我们使用“hexo”+“GitHub Page”搭建blog，需要依赖于git进行部署，部署之前主要配置git依赖，编辑 _config.yml 的 deploy 配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:wliu6/wliu6.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p><p>如果想部署到其他云服务器可以参考：<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">deployment</a></p><p>部署命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure></p><h2 id="访问bolg"><a href="#访问bolg" class="headerlink" title="访问bolg"></a>访问bolg</h2><h3 id="使用GitHub-Page"><a href="#使用GitHub-Page" class="headerlink" title="使用GitHub Page"></a>使用GitHub Page</h3><p>使用<strong>GitHub&ensp;Page</strong>访问博客，只需要将已经写好的博客部署到之前注册号的“GitHub&ensp;reop”，使用<code>username.github.io</code>访问即可。</p><h3 id="使用自己注册的域名"><a href="#使用自己注册的域名" class="headerlink" title="使用自己注册的域名"></a>使用自己注册的域名</h3><p>在GitHub Page repo<a href="https://help.github.com/articles/adding-or-removing-a-custom-domain-for-your-github-pages-site/" target="_blank" rel="noopener">添加域名</a>，域名是你之前注册好的。<br><img src="/resourse/hexo/initialize/8.png" alt="img8"><br><img src="/resourse/hexo/initialize/9.png" alt="img9"></p><p>在站点目录下创建CNAME文件，将域名写入，由于使用“hexo” + “GitHub Page”搭建博客，CNAME文件应该放在source目录下，以防每次部署时被覆盖。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cd hexo_project_dir/hexo/source</span><br><span class="line">$ touch CNAME</span><br><span class="line">$ vim CNAME</span><br><span class="line">$ i # 进入编辑模式，输入域名</span><br><span class="line">$ ESC # 退出编辑模式</span><br><span class="line">$ :wq # 退出并保存</span><br></pre></td></tr></table></figure></p><p>获取博客站点IP<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping username.github.io</span><br></pre></td></tr></table></figure></p><p>最后，进入你注册域名的云服务器站点的管理台，编辑域名解析，A文件记录IP，CNAME记录域名；<br><img src="/resourse/hexo/initialize/10.png" alt="img10"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文讲述如何使用“hexo” + “GitHub Page”搭建自己的博客。&lt;br&gt;&lt;img src=&quot;/resourse/hexo/initialize/0.jpg&quot; alt=&quot;img0&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="blog" scheme="http://wliu6.github.io/categories/blog/"/>
    
    
      <category term="hexo" scheme="http://wliu6.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>CocoaPods Error —— 指定版本问题</title>
    <link href="http://wliu6.github.io/2015/12/10/cocoapods-issue2-md/"/>
    <id>http://wliu6.github.io/2015/12/10/cocoapods-issue2-md/</id>
    <published>2015-12-10T12:28:30.000Z</published>
    <updated>2021-04-21T08:59:21.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>使用pod安装依赖，其中<code>&#39;xxxSDK&#39;</code>仓库指定版本为<code>&#39;1.2.1&#39;</code>，但实际安装的版本是<code>&#39;1.2.6&#39;</code>。本文就此问题，探索一下原因。</p></blockquote><a id="more"></a><hr><p><br></p><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>最近公司项目的某个模块做了大的改动，两组人在两个分支上进行并行开发。通过测试及功能验收后，产品部门打算将这两个大的功能改动作为一版本发布。</p><p>在合并代码过程中，<code>Podfile.lock</code>文件冲突，处理了冲突，发现执行<code>pod install</code>后提示<code>Podfile.lock</code>文件语法有问题。</p><p><br></p><h1 id="尝试解决问题"><a href="#尝试解决问题" class="headerlink" title="尝试解决问题"></a>尝试解决问题</h1><p>程序🐵偷懒天性使然，直接<code>mv Podfile.lock ~/.Trash</code>，再重新执行<code>pod install</code>。完美，安装成功，真是愉快的一天~~~</p><p>生活总是这么有趣，编译项目时发现<code>&#39;xxxSDK&#39;</code>的public接口找不到了。查询了下<code>&#39;xxxSDK&#39;</code>的版本更新日志，找找差异原因。原来是该框架在<code>&#39;1.2.5&#39;</code>版本进行重构，public接口的命名变了。为了不影响上线时间，决定将仓库指定为对于项目稳定的<code>&#39;1.2.1&#39;</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;xxxSDK&apos;, &apos;~&gt; 1.2.1&apos;</span><br></pre></td></tr></table></figure></p><p>重新执行<code>pod install</code>，编译项目发现依然找不到<code>&#39;xxxSDK&#39;</code>的<code>-autoLoginWith:</code>接口，真刺激！！！</p><p><br></p><h1 id="进一步分析问题"><a href="#进一步分析问题" class="headerlink" title="进一步分析问题"></a>进一步分析问题</h1><p>出现问题总是要解决的，接下来继续探索新问题…</p><p>从<code>github</code>直接将<code>&#39;xxxSDK&#39;</code>的代码仓库clone到本地。分别diff该仓库的各个tag分支和公司项目依赖的代码仓库（Tips：项目编译时依赖的代码仓库，位于项目路径下的Pods文件夹下），最后找到实际上目前项目依赖的代码依然是<code>&#39;1.2.6&#39;</code>版本。</p><p>不死心，继续尝试删掉<code>user/work/XXX/Pods/</code>目录下的依赖重新安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pod install --verbose</span><br></pre></td></tr></table></figure></p><p>使用verbose option，等到install进程的更详细输出，从输出可以看到，重新安装依赖的版本依旧是<code>&#39;1.2.6&#39;</code>。</p><p>无奈之下只能去<code>CocoaPods</code>官网去查文档了，找到<a href="https://guides.cocoapods.org/using/the-podfile.html" target="_blank" rel="noopener">有效信息</a>。使用<code>~&gt;</code>语法指定版本，<code>Podfile.lock</code>文件才会对<code>pod install</code>进程进行强制限制，而在开发过程中经常使用的<code>Podfile</code>文件主要作用建立依赖库的引用关系的，对于依赖的版本的限制相对较弱。</p><p>举个例子，例如版本<code>1.2.6</code>，主版本号是1，次版本号是2，修订版本号是6。<code>Podfile</code>文件只限制到次版本号，也就是说之前在<code>Podfile</code>文件指定为版本<code>&#39;1.2.1&#39;</code>，但是实际安装的依赖版本会是<code>&#39;1.2.x&#39;</code>次版本系列的修订版本号最大的仓库。看一下<code>Podfile.lock</code>文件的内容，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -R Podfile.lock</span><br></pre></td></tr></table></figure></p><p>会看到<code>- xxxSDK (~&gt; 1.2.6)</code>。</p><p><br></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><table><thead><tr><th>方法一</th><th>方法二</th></tr></thead><tbody><tr><td>将<code>Podfile.lock</code>文件中的<code>- xxxSDK (~&gt; 1.2.6)</code>修改成<code>- xxxSDK (~&gt; 1.2.1)</code>，重新安装依赖，nice，完美解决问题。</td><td><code>Podfile</code>文件中的<code>pod &#39;xxxSDK&#39;, &#39;~&gt; 1.2.1&#39;</code>修改成<code>pod &#39;xxxSDK&#39;, &#39;1.2.1&#39;</code></td></tr></tbody></table><p><br></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>基于这个问题汇总了一下<code>CocoaPods</code>的<code>Podfile</code>文件的语法：</p><p>1.模糊版本指定:</p><pre><code>&apos;&gt; 0.1&apos; —— 任一高于0.1版的包；&apos;&gt;= 0.1&apos; —— 0.1版的包或任一高于0.1版的包；&apos;&lt; 0.1&apos; —— 任一低于0.1版的包；&apos;&lt;= 0.1&apos; —— 0.1版的包或任一低于0.1版的包；</code></pre><p>2.乐观的版本指定（语法为<code>~&gt;</code>）:</p><pre><code>&apos;~&gt; 0.1.2&apos; —— 高于0.1.2，低于0.2的包；&apos;~&gt; 0.1&apos; —— 高于0.1，低于1.0的包；&apos;~&gt; 0&apos; —— 高于0，跟没有指定一样；</code></pre><p>3.直接（强制）指定</p><pre><code>&apos;0.1.2&apos; —— 0.1.2版的包；</code></pre><p><br></p><h1 id="pick知识点"><a href="#pick知识点" class="headerlink" title="pick知识点"></a>pick知识点</h1><p><code>CocoaPods</code>的版本控制基于<a href="https://semver.org/" target="_blank" rel="noopener">Semantic Versioning 2.0.0</a>，分为主版本、次版本、修订版本。</p><pre><code>主版本号：当你做了不兼容的 API 修改；次版本号：当你做了向下兼容的功能性新增；修订版本号：当你做了向下兼容的问题修正；</code></pre><p>故相对规范的开源仓库，重新设计架构都会更新主版本号。建议各位玩开源的熊蝶再发布版本的时候注意一下<a href="https://semver.org/" target="_blank" rel="noopener"><code>CocoaPods所使用的版本准则</code></a>。</p><p><br></p><h1 id="Tsukkomi"><a href="#Tsukkomi" class="headerlink" title="Tsukkomi"></a>Tsukkomi</h1><p>吐槽一下环信，一家付费提供IM服务的公司，于<code>3.3.7</code>到<code>3.3.8</code>版本修改了其SDK的public属性<code>[EMClient isLoggedIn]</code>的语义直接变更。</p><p><img src="/resourse/iOS/Cocoapods/3.png" alt="img3"><br>既然做付费服务，那么态度能否专业一点。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;使用pod安装依赖，其中&lt;code&gt;&amp;#39;xxxSDK&amp;#39;&lt;/code&gt;仓库指定版本为&lt;code&gt;&amp;#39;1.2.1&amp;#39;&lt;/code&gt;，但实际安装的版本是&lt;code&gt;&amp;#39;1.2.6&amp;#39;&lt;/code&gt;。本文就此问题，探索一下原因。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="development" scheme="http://wliu6.github.io/categories/development/"/>
    
    
      <category term="iOS" scheme="http://wliu6.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
